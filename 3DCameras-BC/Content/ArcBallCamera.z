/************************************************************************************************************/
/* Copyright 2017 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2017                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Arend Danielek                                                                          */
/* Class: ArcBallCamera                                                                                     */
/* Brief: Implements an orbit camera using a object hierarchy approach with an intermediary mount object    */
/* in the hierarchy.                                                                                        */
/************************************************************************************************************/

class ArcBallCamera : ZilchComponent
{
    [Dependency]
    var Transform : Transform;
    
    [Dependency]
    var Camera : Camera;
    
    //Radial distance per second the camera will rotate around the mount
    [Property]
    var RotationSpeed : Real3 = Real3();
    var RotationSpeedRadians : Real3 { get { return Math.ToRadians(this.RotationSpeed); } }
    
    //Max positive rotation around the local X-Axis
    [Property]
    var MaxVerticalAngle : Real = 60.0;
    
    //Min positive rotation around the local X-Axis
    [Property]
    var MinVerticalAngle : Real = -30.0;
    
    //Getter for a reference to the player object via the object hierarchy
    var Player : Cog
    {
        get { return this.Owner.Parent.Parent; }
    }
    
    //Getter for a reference to the mount object via the object hierarchy
    var Mount : Cog
    {
        get { return this.Owner.Parent; }
    }
    
    //Cog Path to the Focus object
    [Property]
    var FocusObjPath : CogPath = null;
    
    //Getter for a reference to the focus object via the CogPath "FocusObjPath"
    var FocusObj : Cog
    {
        get { return this.FocusObjPath.Cog; }
    }
    
    //Target rotation for the camera mount object
    var MountTargetAngles : Real3 = Real3();
    var MountTargetRotation : Quaternion { get { return Math.ToQuaternion(this.MountTargetAngles); } }
    
    //Min pitch constraint
    [Property]
    var MinPitch : Real = -30.0;
    var MinPitchRadians : Real { get { return Math.ToRadians(this.MinPitch); } }
    
    //Max pitch constraint
    [Property]
    var MaxPitch : Real = -30.0;
    var MaxPitchRadians : Real { get { return Math.ToRadians(this.MaxPitch); } }
    
    //Interpolation speed of the camera when it is "zooming"
    [Property]
    var ZoomSpeed : Real = 5.0;
    
    [Property]
    var MinZoom : Real = 3.0;
    
    [Property]
    var MaxZoom : Real = 10.0;
    
    var CurZoom : Real
    {
        get { return Math.Length(this.Transform.Translation); }
        set
        {
            var dir = Math.Normalize(this.Transform.Translation);
            this.Transform.Translation = dir * value;
        }
    }
    
    var TargetZoom : Real = 0.0;
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(this.Space, Events.MouseMove, this.OnMouseMove);
        Zero.Connect(this.Space, Events.MouseScroll, this.OnMouseScroll);
        
        //Store initial value for the target variables
        this.MountTargetAngles = this.Mount.Transform.EulerAngles;
        this.TargetZoom = this.CurZoom;
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        //Set the mount rotation to make the Camera orbit
        this.Mount.Transform.Rotation = this.MountTargetRotation;
        
        //Interpolate towards the current zoom
        this.CurZoom = Math.Lerp(this.CurZoom, this.TargetZoom, this.ZoomSpeed * event.Dt);
    }

    function OnMouseMove(event : ViewportMouseEvent)
    {
        //Convert the mouse data to radians so the integer values are not incredibly large compared to the value range of Radians
        var movement = Math.ToRadians(event.Movement);
        var targetAngles = this.MountTargetAngles + Real3(this.RotationSpeedRadians.X * movement.Y, this.RotationSpeedRadians.Y * -movement.X, 0.0);
        
        //Constrain the pitch of the camera
        targetAngles.X = Math.Clamp(targetAngles.X, this.MinPitchRadians, this.MaxPitchRadians);
        this.MountTargetAngles = targetAngles;
    }

    function OnMouseScroll(event : ViewportMouseEvent)
    {
        //Calculate the new TargetZoom based off the mouse scroll for the frame
        var newZoom = this.TargetZoom - (event.Scroll.Y);
        this.TargetZoom = Math.Clamp(newZoom, this.MinZoom, this.MaxZoom);
    }
}
