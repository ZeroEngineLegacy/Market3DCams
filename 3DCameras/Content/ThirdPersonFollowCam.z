/************************************************************************************************************/
/* Copyright 2017 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/5/2017                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Arend Danielek                                                                          */
/* Class: ThirdPersonFollowCam                                                                              */
/* Brief: Implements a 3D camera which attempts to independently follow and object in third person with out */
/* clipping through geometry.                                                                               */
/************************************************************************************************************/

class ThirdPersonFollowCam : ZilchComponent
{
    [Dependency]
    var Transform : Transform;
    
    [Dependency]
    var Orientation : Orientation;
    
    [Dependency]
    var Camera : Camera;
    
    [Dependency]
    var RigidBody : RigidBody;
    
    [Property]
    var FocusObjectCogPath : CogPath;
    var FocusObject : Cog
    {
        get { return this.FocusObjectCogPath.Cog; } 
    }
    
    var FocusPos : Real3
    {
        get { return this.FocusObject.Transform.WorldTranslation; } 
    }
    
    [Property]
    var LocalOffsetFromFocusObj : Real3 = Real3(0, 3, 5);
    
    var TargetWorldTranslation : Real3
    {
        get { return this.FocusObject.Transform.TransformPoint(this.LocalOffsetFromFocusObj); }
    }
    
    var TargetWorldRotation : Quaternion
    {
        get { return this.Orientation.GetLookAtPointWithUpRotation(this.FocusPos, this.WorldUp); }
    }
    
    [Property]
    var BaseTranslationSpeed : Real = 5.0;
    
    [Property]
    var BaseRotationSpeed : Real = 30.0;
    var BaseRotationSpeedRadians : Real
    {
        get { return Math.ToRadians(this.BaseRotationSpeed); }
    }
    
    [Property]
    var WorldUp : Real3 = Real3(0,1,0);
    
    [Property]
    var ForwardSensorAngle : Real = 30.0;
    var ForwardSensorAngleRad : Real { get { return Math.ToRadians(this.ForwardSensorAngle); } }
    
    [Property]
    var BackwardSensorAngle : Real = 30.0;
    var BackwardSensorAngleRad : Real { get { return Math.ToRadians(this.BackwardSensorAngle); } }
    
    [Property]
    var MinInfluenceDist : Real = 5.0;
    
    [Property]
    var ForwardSensorInfluence : Real = 0.5;
    
    [Property]
    var PaddingRadius : Real = 0.5;
    
    [Property]
    var BackPadding : Real = 1.0;
    
    var ObstacleFilter : CastFilter = CastFilter();
    
    [Property]
    var CameraCollisionGroup : CollisionGroup;
    
    [Property]
    var DrawDebugRays : Boolean = true;
    
    function Initialize(init : CogInitializer)
    {
        this.ObstacleFilter.CollisionGroup = this.CameraCollisionGroup;
        this.ObstacleFilter.IgnoreChildren = true;
        this.ObstacleFilter.IgnoreDynamic = true;
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        //Store the camera's current and target positions locally so they can be modified.
        var curPos = this.Transform.WorldTranslation;
        var newIntendedPos = this.TargetWorldTranslation;
        
        //Construct vector that will shoot out forward and above of the camera for prediction
        //of surfaces which the camera must interpolate under
        var fuRay = Ray();
        fuRay.Start = curPos;
        var fuDir = this.Orientation.WorldForward;
        fuRay.Direction = Math.RotateVector(fuDir, this.Orientation.WorldRight, this.ForwardSensorAngleRad);
        var fuResult = this.Space.PhysicsSpace.CastRayFirstFiltered(fuRay, this.ObstacleFilter);
        
        if(this.DrawDebugRays)
            this.DrawRay(fuRay, fuResult.Distance);
        
        //If the forward-up ray senses and object within MinInfluenceDist then the Y-Axis
        //difference should be used to influence how much the camera is pushed down to go under the object
        if(fuResult.ObjectHit != null  && fuResult.Distance < this.MinInfluenceDist)
        {
            var yDif = fuResult.WorldPosition.Y - this.Transform.WorldTranslation.Y;
            var dif = -yDif * (this.ForwardSensorInfluence/fuResult.Distance);
            newIntendedPos += Real3(0, dif, 0);
        }
        
        //Cast a ray backwards from the camera
        var bRay = Ray();
        bRay.Start = curPos;
        bRay.Direction = -this.Orientation.WorldForward;
        var bResult = this.Space.PhysicsSpace.CastRayFirstFiltered(bRay, this.ObstacleFilter);
        
        if(this.DrawDebugRays)
            this.DrawRay(bRay, bResult.Distance);
        
        //Cast a ray backwards and above the camera
        var buRay = Ray();
        buRay.Start = curPos;
        var buDir = -this.Orientation.WorldForward;
        buRay.Direction = Math.RotateVector(buDir, this.Orientation.WorldRight, -this.BackwardSensorAngleRad);
        var buResult = this.Space.PhysicsSpace.CastRayFirstFiltered(buRay, this.ObstacleFilter);
        
        if(this.DrawDebugRays)
            this.DrawRay(buRay, buResult.Distance);
        
        //Cast a ray back from the focus object's position
        var buCheckRay = Ray();
        buCheckRay.Start = this.FocusPos;
        buCheckRay.Direction = -this.FocusObject.Orientation.WorldForward;
        var buCheckResult = this.Space.PhysicsSpace.CastRayFirstFiltered(buCheckRay, this.ObstacleFilter);
        
        //If there is an object above and behind the camera within MinInfluenceDist and
        //the object does not extend to the ground then move the camera down under the object
        //as the player moves backards under the object.
        if(buResult.ObjectHit != null &&
           buResult.ObjectHit != buCheckResult.ObjectHit &&
           buResult.Distance < this.MinInfluenceDist)
        {
            var yDif = buResult.WorldPosition.Y - this.Transform.WorldTranslation.Y;
            var dif = -yDif * (this.ForwardSensorInfluence/buResult.Distance);
            newIntendedPos += Real3(0, dif, 0);
        }
        //If there is an object behind the camera that can not be spatially avoided and would 
        //clip the camera zoom the camera in to avoid clipping into the object
        else if(bResult.ObjectHit != null &&
                bResult.Distance < this.BackPadding &&
                Math.Length(this.LocalOffsetFromFocusObj) > Math.Distance(this.FocusPos, bResult.WorldPosition))
        {
            var camDistDif = this.BackPadding - (bResult.Distance * 1.1);
            var focusDif = curPos - this.FocusPos;
            
            newIntendedPos = this.FocusPos + (Math.Normalize(focusDif) * (Math.Length(focusDif) - camDistDif));
        }
        
        //Local axis aligned rays to act as oriented close range buffer orthoganal to the zoom axis
        var uRay = Ray();
        uRay.Start = curPos;
        uRay.Direction = this.Orientation.LocalUp;
        var uResult = this.Space.PhysicsSpace.CastRayFirstFiltered(uRay, this.ObstacleFilter);
        
        var dRay = Ray();
        dRay.Start = curPos;
        dRay.Direction = -this.Orientation.LocalUp;
        var dResult = this.Space.PhysicsSpace.CastRayFirstFiltered(dRay, this.ObstacleFilter);
        
        var rRay = Ray();
        rRay.Start = curPos;
        rRay.Direction = this.Orientation.LocalRight;
        var rResult = this.Space.PhysicsSpace.CastRayFirstFiltered(rRay, this.ObstacleFilter);
        
        var lRay = Ray();
        lRay.Start = curPos;
        lRay.Direction = -this.Orientation.LocalRight;
        var lResult = this.Space.PhysicsSpace.CastRayFirstFiltered(lRay, this.ObstacleFilter);
        
        //Use Axis aligned casts for padding checks.
        //Adjust the newIntendedPos by the differences between the raycast distances and PaddingRadius
        if(uResult.ObjectHit != null && uResult.Distance < this.PaddingRadius)
        {
            var dif = this.PaddingRadius - uResult.Distance;
            newIntendedPos += -uRay.Direction * dif;
        }
        if(dResult.ObjectHit != null && dResult.Distance < this.PaddingRadius)
        {
            var dif = this.PaddingRadius - dResult.Distance;
            newIntendedPos += -dRay.Direction * dif;
        }
        if(rResult.ObjectHit != null && rResult.Distance < this.PaddingRadius)
        {
            var dif = this.PaddingRadius - rResult.Distance;
            newIntendedPos += -rRay.Direction * dif;
        }
        if(lResult.ObjectHit != null && lResult.Distance < this.PaddingRadius)
        {
            var dif = this.PaddingRadius - lResult.Distance;
            newIntendedPos += -lRay.Direction * dif;
        }
        
        //Interpolate towards the new Translation/Rotation
        var newPos = Math.Lerp(this.Transform.WorldTranslation, newIntendedPos, this.BaseTranslationSpeed * event.Dt);
        this.Transform.Translation = newPos;
        
        var newRot = Math.Slerp(this.Transform.Rotation, this.TargetWorldRotation, this.BaseRotationSpeedRadians * event.Dt);
        this.Transform.Rotation = newRot;
    }
    
    function DrawRay(ray : Ray, len : Real)
    {
        if(!this.DrawDebugRays)
            return;
        
        var line = DebugLine();
        line.Start = ray.Start;
        line.End = ray.Start + (ray.Direction * Math.Clamp(len, 1.0, 100.0));
        line.Color = Real4(1,1,1,1);
        line.HeadSize = 0.25;
        line.OnTop = true;
        DebugDraw.Add(line);
    }
}
