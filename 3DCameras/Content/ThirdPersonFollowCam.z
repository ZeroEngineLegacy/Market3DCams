class ThirdPersonFollowCam : ZilchComponent
{
    [Dependency]
    var Transform : Transform;
    
    [Dependency]
    var Orientation : Orientation;
    
    [Dependency]
    var Camera : Camera;
    
    [Dependency]
    var RigidBody : RigidBody;
    
    //Should this component operate
    [Property]
    var Enabled : Boolean = true;
    
    //Is this component currently operating
    var Active : Boolean = false;
    
    [Property]
    var FocusObjectCogPath : CogPath;
    var FocusObject : Cog
    {
        get { return this.FocusObjectCogPath.Cog; } 
    }
    
    var FocusPos : Real3
    {
        get { return this.FocusObject.Transform.WorldTranslation; } 
    }
    
    [Property]
    var LocalOffsetFromFocusObj : Real3 = Real3(0, 3, 5);
    
    var TargetWorldTranslation : Real3
    {
        get { return this.FocusObject.Transform.TransformPoint(this.LocalOffsetFromFocusObj); }
    }
    
    var TargetWorldRotation : Quaternion
    {
        get { return this.Orientation.GetLookAtPointWithUpRotation(this.FocusPos, this.WorldUp); }
    }
    
    [Property]
    var BaseTranslationSpeed : Real = 5.0;
    
    [Property]
    var BaseRotationSpeed : Real = 30.0;
    var BaseRotationSpeedRadians : Real
    {
        get { return Math.ToRadians(this.BaseRotationSpeed); }
    }
    
    [Property]
    var WorldUp : Real3 = Real3(0,1,0);
    
    [Property]
    var ForwardSensorAngle : Real = 30.0;
    var ForwardSensorAngleRad : Real { get { return Math.ToRadians(this.ForwardSensorAngle); } }
    
    [Property]
    var BackwardSensorAngle : Real = 30.0;
    var BackwardSensorAngleRad : Real { get { return Math.ToRadians(this.BackwardSensorAngle); } }
    
    [Property]
    var MinInfluenceDist : Real = 5.0;
    
    [Property]
    var ForwardSensorInfluence : Real = 0.5;
    
    [Property]
    var PaddingRadius : Real = 0.5;
    
    [Property]
    var BackPadding : Real = 1.0;
    
    var ObstacleFilter : CastFilter = CastFilter();
    
    [Property]
    var CameraCollisionGroup : CollisionGroup;
    
    function Initialize(init : CogInitializer)
    {
        this.ObstacleFilter.CollisionGroup = this.CameraCollisionGroup;
        this.ObstacleFilter.IgnoreChildren = true;
        this.ObstacleFilter.IgnoreDynamic = true;
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        var curPos = this.Transform.WorldTranslation;
        var newIntendedPos = this.TargetWorldTranslation;
        
        var rayFromFocus = Ray();
        rayFromFocus.Start = this.FocusPos;
        rayFromFocus.Direction = Math.Normalize(newIntendedPos - this.FocusPos);
        var rayFromFocusResult = this.Space.PhysicsSpace.CastRayFirstFiltered(rayFromFocus, this.ObstacleFilter);
        
        //Construct vectors that will shoot out forward  of the camera for prediction
        var fuRay = Ray();
        fuRay.Start = curPos;
        var dir = this.Orientation.WorldForward;
        fuRay.Direction = Math.RotateVector(dir, this.Orientation.WorldRight, this.ForwardSensorAngleRad);
        var fuResult = this.Space.PhysicsSpace.CastRayFirstFiltered(fuRay, this.ObstacleFilter);
        this.DrawRay(fuRay, fuResult.Distance);
        
        
        if(fuResult.ObjectHit != null  && fuResult.Distance < this.MinInfluenceDist)
        {
            var yDif = fuResult.WorldPosition.Y - this.Transform.WorldTranslation.Y;
            var dif = -yDif * (this.ForwardSensorInfluence/fuResult.Distance);
            newIntendedPos += Real3(0, dif, 0);
        }
        
        else if(rayFromFocusResult.ObjectHit != null  && fuResult.Distance < this.MinInfluenceDist)
        {
            Console.WriteLine(rayFromFocusResult.ObjectHit);
            var hitPos = rayFromFocusResult.WorldPosition;
            var curDif = Math.Distance(newIntendedPos, this.FocusPos);
            var tdir = Math.Normalize(newIntendedPos - this.FocusPos);
            newIntendedPos = this.FocusPos + ((rayFromFocusResult.Distance - this.BackPadding) * tdir);
        }
        
        var bRay = Ray();
        bRay.Start = curPos;
        bRay.Direction = -this.Orientation.WorldForward;
        var bResult = this.Space.PhysicsSpace.CastRayFirstFiltered(bRay, this.ObstacleFilter);
        this.DrawRay(bRay, bResult.Distance);
        
        //Console.WriteLine(blResult.Distance < this.BackPadding);
        if(bResult.ObjectHit != null && bResult.Distance < this.BackPadding && Math.Length(this.LocalOffsetFromFocusObj) > Math.Distance(this.FocusPos, bResult.WorldPosition))
        {
            var camDistDif = this.BackPadding - (bResult.Distance * 1.1);
            var focusDif = curPos - this.FocusPos;
            
            newIntendedPos = this.FocusPos + (Math.Normalize(focusDif) * (Math.Length(focusDif) - camDistDif));
        }
        
        
        //Axis aligned rays
        var uRay = Ray();
        uRay.Start = newIntendedPos;
        uRay.Direction = this.Orientation.LocalUp;
        var uResult = this.Space.PhysicsSpace.CastRayFirstFiltered(uRay, this.ObstacleFilter);
        this.DrawRay(uRay, uResult.Distance);
        
        var dRay = Ray();
        dRay.Start = newIntendedPos;
        dRay.Direction = -this.Orientation.LocalUp;
        var dResult = this.Space.PhysicsSpace.CastRayFirstFiltered(dRay, this.ObstacleFilter);
        
        var rRay = Ray();
        rRay.Start = newIntendedPos;
        rRay.Direction = this.Orientation.LocalRight;
        var rResult = this.Space.PhysicsSpace.CastRayFirstFiltered(rRay, this.ObstacleFilter);
        
        var lRay = Ray();
        lRay.Start = this.Owner.Transform.WorldTranslation;
        lRay.Direction = -this.Orientation.LocalRight;
        var lResult = this.Space.PhysicsSpace.CastRayFirstFiltered(lRay, this.ObstacleFilter);
        
        //USe Axis aligned casts for padding checks
        if(uResult.ObjectHit != null && uResult.Distance < this.PaddingRadius)
        {
            var dif = this.PaddingRadius - uResult.Distance;
            newIntendedPos += -uRay.Direction * dif;
        }
        if(dResult.ObjectHit != null && dResult.Distance < this.PaddingRadius)
        {
            var dif = this.PaddingRadius - dResult.Distance;
            newIntendedPos += -dRay.Direction * dif;
        }
        if(rResult.ObjectHit != null && rResult.Distance < this.PaddingRadius)
        {
            var dif = this.PaddingRadius - rResult.Distance;
            newIntendedPos += -rRay.Direction * dif;
        }
        if(lResult.ObjectHit != null && lResult.Distance < this.PaddingRadius)
        {
            var dif = this.PaddingRadius - lResult.Distance;
            newIntendedPos += -lRay.Direction * dif;
        }
        
        var newPos = Math.Lerp(this.Transform.WorldTranslation, newIntendedPos, this.BaseTranslationSpeed * event.Dt);
        this.Transform.Translation = newPos;
        
        var newRot = Math.Slerp(this.Transform.Rotation, this.TargetWorldRotation, this.BaseRotationSpeedRadians * event.Dt);
        this.Transform.Rotation = newRot;
    }
    
    function DrawRay(ray : Ray, len : Real)
    {
        var line = DebugLine();
        line.Start = ray.Start;
        line.End = ray.Start + (ray.Direction * Math.Clamp(len, 1.0, 100.0));
        line.Color = Real4(1,1,1,1);
        line.HeadSize = 0.25;
        line.OnTop = true;
        DebugDraw.Add(line);
    }
}
