class ThirdPersonFollowCam : ZilchComponent
{
    [Dependency]
    var Transform : Transform;
    
    [Dependency]
    var Orientation : Orientation;
    
    [Dependency]
    var Camera : Camera;
    
    [Dependency]
    var RigidBody : RigidBody;
    
    //Should this component operate
    [Property]
    var Enabled : Boolean = true;
    
    //Is this component currently operating
    var Active : Boolean = false;
    
    [Property]
    var FocusObjectCogPath : CogPath;
    var FocusObject : Cog
    {
        get { return this.FocusObjectCogPath.Cog; } 
    }
    
    var FocusPos : Real3
    {
        get { return this.FocusObject.Transform.WorldTranslation; } 
    }
    
    [Property]
    var LocalOffsetFromFocusObj : Real3 = Real3(0, 3, 5);
    
    var TargetWorldTranslation : Real3
    {
        get { return this.FocusObject.Transform.TransformPoint(this.LocalOffsetFromFocusObj); }
    }
    
    var TargetWorldRotation : Quaternion
    {
        get { return this.Orientation.GetLookAtPointWithUpRotation(this.FocusPos, this.WorldUp); }
    }
    
    [Property]
    var BaseTranslationSpeed : Real = 5.0;
    
    [Property]
    var BaseRotationSpeed : Real = 30.0;
    var BaseRotationSpeedRadians : Real
    {
        get { return Math.ToRadians(this.BaseRotationSpeed); }
    }
    
    [Property]
    var WorldUp : Real3 = Real3(0,1,0);
    
    [Property]
    var ForwardSensorAngle : Real = 30.0;
    var ForwardSensorAngleRad : Real { get { return Math.ToRadians(this.ForwardSensorAngle); } }
    
    [Property]
    var BackwardSensorAngle : Real = 30.0;
    var BackwardSensorAngleRad : Real { get { return Math.ToRadians(this.BackwardSensorAngle); } }
    
    [Property]
    var MinInfluenceDist : Real = 5.0;
    
    [Property]
    var ForwardSensorInfluence : Real = 0.5;
    
    [Property]
    var PaddingRadius : Real = 0.5;
    
    [Property]
    var BackPadding : Real = 1.0;
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        var targetWorldTranslation = this.TargetWorldTranslation;
        var newIntendedPos = Math.Lerp(this.Transform.Translation, targetWorldTranslation, this.BaseTranslationSpeed * event.Dt);
        
        //var rayFromFocus = Ray();
        //rayFromFocus.Start = this.FocusPos;
        //rayFromFocus.Direction = Math.Normalize(newIntendedPos - this.FocusPos);
        //var rayFromFocusResult = this.Space.PhysicsSpace.CastRayFirst(rayFromFocus);
        //
        //if(rayFromFocusResult.ObjectHit != null)
        //{
        //    var hitPos = rayFromFocusResult.WorldPosition;
        //    
        //}
        
        //Construct vectors that will shoot out forward  of the camera for prediction
        var fuRay = Ray();
        fuRay.Start = newIntendedPos;
        var dir = this.Orientation.WorldForward;
        fuRay.Direction = Math.RotateVector(dir, this.Orientation.WorldRight, this.ForwardSensorAngleRad);
        var fuResult = this.Space.PhysicsSpace.CastRayFirst(fuRay);
        this.DrawRay(fuRay, fuResult.Distance);
        
        //var fdRay = Ray();
        //fdRay.Start = newIntendedPos;
        //fdRay.Direction = Math.RotateVector(this.Orientation.WorldForward, this.Orientation.WorldRight, -this.ForwardSensorAngleRad);
        //var fdResult = this.Space.PhysicsSpace.CastRayFirst(fdRay);
        //this.DrawRay(fdRay, fdResult.Distance);
        
        
        if(fuResult.ObjectHit != null  && fuResult.Distance < this.MinInfluenceDist)
        {
            var yDif = fuResult.WorldPosition.Y - this.Transform.WorldTranslation.Y;
            var dif = -yDif * (this.ForwardSensorInfluence/fuResult.Distance) * event.Dt;
            //Console.WriteLine("fuResult.Distance: `fuResult.Distance`");
            //Console.WriteLine("dif: `dif`");
            newIntendedPos += Real3(0, dif, 0);
        }
        //if(fdResult.ObjectHit != null && fuResult.Distance > fdResult.Distance && fdResult.Distance < this.MinInfluenceDist)
        //{
        //    var yDif = fdResult.WorldPosition.Y - this.Transform.WorldTranslation.Y;
        //    Console.WriteLine("fdResult.Distance: `fdResult.Distance`");
        //    newIntendedPos += Real3(0, -yDif * this.ForwardSensorInfluence * event.Dt, 0);
        //}
        
        var brRay = Ray();
        brRay.Start = this.Owner.Transform.WorldTranslation;
        brRay.Direction = Math.RotateVector(-this.Orientation.WorldForward, this.Orientation.WorldUp, -this.ForwardSensorAngleRad);
        var brResult = this.Space.PhysicsSpace.CastRayFirst(brRay);
        this.DrawRay(brRay, brResult.Distance);
        
        var blRay = Ray();
        blRay.Start = this.Owner.Transform.WorldTranslation;
        blRay.Direction = Math.RotateVector(-this.Orientation.WorldForward, this.Orientation.WorldUp, this.ForwardSensorAngleRad);
        var blResult = this.Space.PhysicsSpace.CastRayFirst(blRay);
        this.DrawRay(blRay, blResult.Distance);
        
        //Console.WriteLine(blResult.Distance < this.BackPadding);
        if(brResult.ObjectHit != null && brResult.Distance < this.BackPadding && (brResult.Distance > blResult.Distance || blResult.ObjectHit == null))
        {
            var dif = Math.Abs(this.BackPadding - brResult.Distance);
            var curDif = Math.Distance(newIntendedPos, this.FocusPos);
            var tdir = Math.Normalize(newIntendedPos - this.FocusPos);
            newIntendedPos = this.FocusPos + ((curDif - dif) * tdir);
        }
        
        else if(blResult.ObjectHit != null && blResult.Distance < this.BackPadding && (brResult.Distance< blResult.Distance || brResult.ObjectHit == null))
        {
            var dif = Math.Abs(this.BackPadding - blResult.Distance);
            var curDif = Math.Distance(newIntendedPos, this.FocusPos);
            var tdir = Math.Normalize(newIntendedPos - this.FocusPos);
            newIntendedPos = this.FocusPos + ((curDif - dif) * tdir);
        }
        
        ////Axis aligned rays
        //var uRay = Ray();
        //uRay.Start = newIntendedPos;
        //uRay.Direction = this.Orientation.LocalUp;
        //var uResult = this.Space.PhysicsSpace.CastRayFirst(uRay);
        //this.DrawRay(uRay, uResult.Distance);
        //
        //var dRay = Ray();
        //dRay.Start = newIntendedPos;
        //dRay.Direction = -this.Orientation.LocalUp;
        //var dResult = this.Space.PhysicsSpace.CastRayFirst(dRay);
        //
        //var rRay = Ray();
        //rRay.Start = newIntendedPos;
        //rRay.Direction = this.Orientation.LocalRight;
        //var rResult = this.Space.PhysicsSpace.CastRayFirst(rRay);
        //
        //var lRay = Ray();
        //lRay.Start = this.Owner.Transform.WorldTranslation;
        //lRay.Direction = -this.Orientation.LocalRight;
        //var lResult = this.Space.PhysicsSpace.CastRayFirst(lRay);
        //
        ////USe Axis aligned casts for padding checks
        //if(uResult.ObjectHit != null && uResult.Distance < this.PaddingRadius)
        //{
        //    var dif = this.PaddingRadius - uResult.Distance;
        //    newIntendedPos += -uRay.Direction * dif;
        //}
        //if(dResult.ObjectHit != null && dResult.Distance < this.PaddingRadius)
        //{
        //    var dif = this.PaddingRadius - dResult.Distance;
        //    newIntendedPos += -dRay.Direction * dif;
        //}
        //if(rResult.ObjectHit != null && rResult.Distance < this.PaddingRadius)
        //{
        //    var dif = this.PaddingRadius - rResult.Distance;
        //    newIntendedPos += -rRay.Direction * dif;
        //}
        //if(lResult.ObjectHit != null && lResult.Distance < this.PaddingRadius)
        //{
        //    var dif = this.PaddingRadius - lResult.Distance;
        //    newIntendedPos += -lRay.Direction * dif;
        //}
        
        var newPos = newIntendedPos;
        this.Transform.Translation = newPos;
        
        var newRot = Math.Slerp(this.Transform.Rotation, this.TargetWorldRotation, this.BaseRotationSpeedRadians * event.Dt);
        this.Transform.Rotation = newRot;
    }
    
    function DrawRay(ray : Ray, len : Real)
    {
        var line = DebugLine();
        line.Start = ray.Start;
        line.End = ray.Start + (ray.Direction * Math.Clamp(len, 1.0, 100.0));
        line.Color = Real4(1,1,1,1);
        line.HeadSize = 0.25;
        line.OnTop = true;
        DebugDraw.Add(line);
    }
}
